{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { EventEmitter } from '@unimodules/core';\nvar GeocoderError = function (_Error) {\n  _inherits(GeocoderError, _Error);\n  var _super = _createSuper(GeocoderError);\n  function GeocoderError() {\n    var _this;\n    _classCallCheck(this, GeocoderError);\n    _this = _super.call(this, 'Geocoder service is not available for this device.');\n    _this.code = 'E_NO_GEOCODER';\n    return _this;\n  }\n  return GeocoderError;\n}(_wrapNativeSuper(Error));\nvar emitter = new EventEmitter({});\nfunction positionToJSON(position) {\n  if (!position) return null;\n  var _position$coords = position.coords,\n    coords = _position$coords === void 0 ? {} : _position$coords,\n    timestamp = position.timestamp;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp: timestamp\n  };\n}\nexport default {\n  get name() {\n    return 'ExpoLocation';\n  },\n  getProviderStatusAsync: function getProviderStatusAsync() {\n    return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", {\n              locationServicesEnabled: 'geolocation' in navigator\n            });\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getCurrentPositionAsync: function getCurrentPositionAsync(options) {\n    return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              return navigator.geolocation.getCurrentPosition(function (position) {\n                return resolve(positionToJSON(position));\n              }, reject, options);\n            }));\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  removeWatchAsync: function removeWatchAsync(watchId) {\n    return _regeneratorRuntime.async(function removeWatchAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            navigator.geolocation.clearWatch(watchId);\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  watchDeviceHeading: function watchDeviceHeading(headingId) {\n    return _regeneratorRuntime.async(function watchDeviceHeading$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            console.warn('Location.watchDeviceHeading: is not supported on web');\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  hasServicesEnabledAsync: function hasServicesEnabledAsync() {\n    return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", 'geolocation' in navigator);\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  geocodeAsync: function geocodeAsync() {\n    return _regeneratorRuntime.async(function geocodeAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            throw new GeocoderError();\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  reverseGeocodeAsync: function reverseGeocodeAsync() {\n    return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            throw new GeocoderError();\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  watchPositionImplAsync: function watchPositionImplAsync(watchId, options) {\n    return _regeneratorRuntime.async(function watchPositionImplAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new Promise(function (resolve) {\n              watchId = global.navigator.geolocation.watchPosition(function (location) {\n                emitter.emit('Expo.locationChanged', {\n                  watchId: watchId,\n                  location: positionToJSON(location)\n                });\n              }, null, options);\n              resolve(watchId);\n            }));\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  requestPermissionsAsync: function requestPermissionsAsync() {\n    return _regeneratorRuntime.async(function requestPermissionsAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", new Promise(function (resolve) {\n              navigator.geolocation.getCurrentPosition(function () {\n                return resolve({\n                  status: 'granted'\n                });\n              }, function (_ref) {\n                var code = _ref.code;\n                if (code === 1) {\n                  resolve({\n                    status: 'denied'\n                  });\n                } else {\n                  resolve({\n                    status: 'undetermined'\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"mappings":"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","names":["EventEmitter","GeocoderError","code","Error","emitter","positionToJSON","position","coords","timestamp","latitude","longitude","altitude","accuracy","altitudeAccuracy","heading","speed","name","getProviderStatusAsync","locationServicesEnabled","navigator","getCurrentPositionAsync","options","Promise","resolve","reject","geolocation","getCurrentPosition","removeWatchAsync","watchId","clearWatch","watchDeviceHeading","headingId","console","warn","hasServicesEnabledAsync","geocodeAsync","reverseGeocodeAsync","watchPositionImplAsync","global","watchPosition","emit","location","requestPermissionsAsync","status"],"sourceRoot":"","sources":["../src/ExpoLocation.web.ts"],"sourcesContent":["import { EventEmitter } from '@unimodules/core';\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\n\ninterface Position {\n  coords: Coordinates;\n  timestamp: number;\n}\n\ninterface PermissionResult {\n  status: string;\n}\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\nconst emitter = new EventEmitter({} as any);\n\nfunction positionToJSON(position: any): Position | null {\n  if (!position) return null;\n\n  const { coords = {}, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getCurrentPositionAsync(options: object): Promise<Position | null> {\n    return new Promise<Position | null>((resolve, reject) =>\n      navigator.geolocation.getCurrentPosition(\n        position => resolve(positionToJSON(position)),\n        reject,\n        options\n      )\n    );\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: object): Promise<string> {\n    return new Promise<string>(resolve => {\n      // @ts-ignore\n      watchId = global.navigator.geolocation.watchPosition(\n        location => {\n          emitter.emit('Expo.locationChanged', { watchId, location: positionToJSON(location) });\n        },\n        null,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n  async requestPermissionsAsync(): Promise<PermissionResult> {\n    return new Promise<PermissionResult>(resolve => {\n      navigator.geolocation.getCurrentPosition(\n        () => resolve({ status: 'granted' }),\n        ({ code }) => {\n          if (code === 1 /* PERMISSION_DENIED */) {\n            resolve({ status: 'denied' });\n          } else {\n            resolve({ status: 'undetermined' });\n          }\n        }\n      );\n    });\n  },\n};\n"]},"metadata":{},"sourceType":"module"}