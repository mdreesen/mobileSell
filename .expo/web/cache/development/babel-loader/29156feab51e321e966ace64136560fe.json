{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport { EventEmitter, Platform, CodedError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport { PermissionStatus } from 'unimodules-permissions-interface';\nimport ExpoLocation from \"./ExpoLocation\";\nvar LocationEventEmitter = new EventEmitter(ExpoLocation);\nexport { PermissionStatus };\nvar LocationAccuracy;\n(function (LocationAccuracy) {\n  LocationAccuracy[LocationAccuracy[\"Lowest\"] = 1] = \"Lowest\";\n  LocationAccuracy[LocationAccuracy[\"Low\"] = 2] = \"Low\";\n  LocationAccuracy[LocationAccuracy[\"Balanced\"] = 3] = \"Balanced\";\n  LocationAccuracy[LocationAccuracy[\"High\"] = 4] = \"High\";\n  LocationAccuracy[LocationAccuracy[\"Highest\"] = 5] = \"Highest\";\n  LocationAccuracy[LocationAccuracy[\"BestForNavigation\"] = 6] = \"BestForNavigation\";\n})(LocationAccuracy || (LocationAccuracy = {}));\nvar LocationActivityType;\n(function (LocationActivityType) {\n  LocationActivityType[LocationActivityType[\"Other\"] = 1] = \"Other\";\n  LocationActivityType[LocationActivityType[\"AutomotiveNavigation\"] = 2] = \"AutomotiveNavigation\";\n  LocationActivityType[LocationActivityType[\"Fitness\"] = 3] = \"Fitness\";\n  LocationActivityType[LocationActivityType[\"OtherNavigation\"] = 4] = \"OtherNavigation\";\n  LocationActivityType[LocationActivityType[\"Airborne\"] = 5] = \"Airborne\";\n})(LocationActivityType || (LocationActivityType = {}));\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\nexport var GeofencingEventType;\n(function (GeofencingEventType) {\n  GeofencingEventType[GeofencingEventType[\"Enter\"] = 1] = \"Enter\";\n  GeofencingEventType[GeofencingEventType[\"Exit\"] = 2] = \"Exit\";\n})(GeofencingEventType || (GeofencingEventType = {}));\nexport var GeofencingRegionState;\n(function (GeofencingRegionState) {\n  GeofencingRegionState[GeofencingRegionState[\"Unknown\"] = 0] = \"Unknown\";\n  GeofencingRegionState[GeofencingRegionState[\"Inside\"] = 1] = \"Inside\";\n  GeofencingRegionState[GeofencingRegionState[\"Outside\"] = 2] = \"Outside\";\n})(GeofencingRegionState || (GeofencingRegionState = {}));\nvar nextWatchId = 0;\nvar headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\nvar watchCallbacks = {};\nvar deviceEventSubscription;\nvar headingEventSub;\nvar googleApiKey;\nvar googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\nexport function getProviderStatusAsync() {\n  return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", ExpoLocation.getProviderStatusAsync());\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function enableNetworkProviderAsync() {\n  return _regeneratorRuntime.async(function enableNetworkProviderAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(Platform.OS === 'android')) {\n            _context2.next = 2;\n            break;\n          }\n          return _context2.abrupt(\"return\", ExpoLocation.enableNetworkProviderAsync());\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getCurrentPositionAsync() {\n  var options,\n    _args3 = arguments;\n  return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n          return _context3.abrupt(\"return\", ExpoLocation.getCurrentPositionAsync(options));\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getLastKnownPositionAsync() {\n  return _regeneratorRuntime.async(function getLastKnownPositionAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.abrupt(\"return\", ExpoLocation.getLastKnownPositionAsync());\n        case 1:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getHeadingAsync() {\n  return _regeneratorRuntime.async(function getHeadingAsync$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          return _context6.abrupt(\"return\", new Promise(function _callee(resolve, reject) {\n            var tries, headingSub, done, subscription, _tries;\n            return _regeneratorRuntime.async(function _callee$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    _context5.prev = 0;\n                    if (!headingEventSub) {\n                      _context5.next = 6;\n                      break;\n                    }\n                    tries = 0;\n                    headingSub = LocationEventEmitter.addListener('Expo.headingChanged', function (_ref) {\n                      var heading = _ref.heading;\n                      if (heading.accuracy > 1 || tries > 5) {\n                        resolve(heading);\n                        LocationEventEmitter.removeSubscription(headingSub);\n                      } else {\n                        tries += 1;\n                      }\n                    });\n                    _context5.next = 12;\n                    break;\n                  case 6:\n                    done = false;\n                    _tries = 0;\n                    _context5.next = 10;\n                    return _regeneratorRuntime.awrap(watchHeadingAsync(function (heading) {\n                      if (!done) {\n                        if (heading.accuracy > 1 || _tries > 5) {\n                          subscription.remove();\n                          resolve(heading);\n                          done = true;\n                        } else {\n                          _tries += 1;\n                        }\n                      } else {\n                        subscription.remove();\n                      }\n                    }));\n                  case 10:\n                    subscription = _context5.sent;\n                    if (done) {\n                      subscription.remove();\n                    }\n                  case 12:\n                    _context5.next = 17;\n                    break;\n                  case 14:\n                    _context5.prev = 14;\n                    _context5.t0 = _context5[\"catch\"](0);\n                    reject(_context5.t0);\n                  case 17:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, null, null, [[0, 14]], Promise);\n          }));\n        case 1:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchHeadingAsync(callback) {\n  return _regeneratorRuntime.async(function watchHeadingAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          if (headingEventSub) {\n            _removeHeadingWatcher(headingId);\n          }\n          headingEventSub = LocationEventEmitter.addListener('Expo.headingChanged', function (_ref2) {\n            var watchId = _ref2.watchId,\n              heading = _ref2.heading;\n            var callback = watchCallbacks[watchId];\n            if (callback) {\n              callback(heading);\n            } else {\n              ExpoLocation.removeWatchAsync(watchId);\n            }\n          });\n          headingId = _getNextWatchId();\n          watchCallbacks[headingId] = callback;\n          _context7.next = 6;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchDeviceHeading(headingId));\n        case 6:\n          return _context7.abrupt(\"return\", {\n            remove: function remove() {\n              _removeHeadingWatcher(headingId);\n            }\n          });\n        case 7:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener('Expo.locationChanged', function (_ref3) {\n      var watchId = _ref3.watchId,\n        location = _ref3.location;\n      var callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(location);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    });\n  }\n}\nexport function geocodeAsync(address) {\n  return _regeneratorRuntime.async(function geocodeAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          return _context8.abrupt(\"return\", ExpoLocation.geocodeAsync(address).catch(function (error) {\n            var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n            if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n              if (!googleApiKey) {\n                throw new CodedError(error.code, error.message + \" Please set a Google API Key to use geocoding.\");\n              }\n              return _googleGeocodeAsync(address);\n            }\n            throw error;\n          }));\n        case 1:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function reverseGeocodeAsync(location) {\n  return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(typeof location.latitude !== 'number' || typeof location.longitude !== 'number')) {\n            _context9.next = 2;\n            break;\n          }\n          throw new TypeError('Location should be an object with number properties `latitude` and `longitude`.');\n        case 2:\n          return _context9.abrupt(\"return\", ExpoLocation.reverseGeocodeAsync(location).catch(function (error) {\n            var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n            if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n              if (!googleApiKey) {\n                throw new CodedError(error.code, error.message + \" Please set a Google API Key to use geocoding.\");\n              }\n              return _googleReverseGeocodeAsync(location);\n            }\n            throw error;\n          }));\n        case 3:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\nfunction _googleGeocodeAsync(address) {\n  var result, resultObject;\n  return _regeneratorRuntime.async(function _googleGeocodeAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          _context10.next = 2;\n          return _regeneratorRuntime.awrap(fetch(googleApiUrl + \"?key=\" + googleApiKey + \"&address=\" + encodeURI(address)));\n        case 2:\n          result = _context10.sent;\n          _context10.next = 5;\n          return _regeneratorRuntime.awrap(result.json());\n        case 5:\n          resultObject = _context10.sent;\n          if (!(resultObject.status === 'ZERO_RESULTS')) {\n            _context10.next = 8;\n            break;\n          }\n          return _context10.abrupt(\"return\", []);\n        case 8:\n          assertGeocodeResults(resultObject);\n          return _context10.abrupt(\"return\", resultObject.results.map(function (result) {\n            var location = result.geometry.location;\n            return {\n              latitude: location.lat,\n              longitude: location.lng\n            };\n          }));\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _googleReverseGeocodeAsync(options) {\n  var result, resultObject;\n  return _regeneratorRuntime.async(function _googleReverseGeocodeAsync$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          _context11.next = 2;\n          return _regeneratorRuntime.awrap(fetch(googleApiUrl + \"?key=\" + googleApiKey + \"&latlng=\" + options.latitude + \",\" + options.longitude));\n        case 2:\n          result = _context11.sent;\n          _context11.next = 5;\n          return _regeneratorRuntime.awrap(result.json());\n        case 5:\n          resultObject = _context11.sent;\n          if (!(resultObject.status === 'ZERO_RESULTS')) {\n            _context11.next = 8;\n            break;\n          }\n          return _context11.abrupt(\"return\", []);\n        case 8:\n          assertGeocodeResults(resultObject);\n          return _context11.abrupt(\"return\", resultObject.results.map(function (result) {\n            var address = {};\n            result.address_components.forEach(function (component) {\n              if (component.types.includes('locality')) {\n                address.city = component.long_name;\n              } else if (component.types.includes('street_address')) {\n                address.street = component.long_name;\n              } else if (component.types.includes('administrative_area_level_1')) {\n                address.region = component.long_name;\n              } else if (component.types.includes('country')) {\n                address.country = component.long_name;\n              } else if (component.types.includes('postal_code')) {\n                address.postalCode = component.long_name;\n              } else if (component.types.includes('point_of_interest')) {\n                address.name = component.long_name;\n              }\n            });\n            return address;\n          }));\n        case 10:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction assertGeocodeResults(resultObject) {\n  var status = resultObject.status,\n    error_message = resultObject.error_message;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(status, 'the request could not be processed due to a server error. The request may succeed if you try again.');\n    }\n    throw new CodedError(status, \"An error occurred during geocoding.\");\n  }\n}\nfunction watchPosition(success, error, options) {\n  _maybeInitializeEmitterSubscription();\n  var watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(function (err) {\n    _removeWatcher(watchId);\n    error({\n      watchId: watchId,\n      message: err.message,\n      code: err.code\n    });\n  });\n  return watchId;\n}\nexport function watchPositionAsync(options, callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchPositionAsync$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          _maybeInitializeEmitterSubscription();\n          watchId = _getNextWatchId();\n          watchCallbacks[watchId] = callback;\n          _context12.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchPositionImplAsync(watchId, options));\n        case 5:\n          return _context12.abrupt(\"return\", {\n            remove: function remove() {\n              _removeWatcher(watchId);\n            }\n          });\n        case 6:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction clearWatch(watchId) {\n  _removeWatcher(watchId);\n}\nfunction _removeWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\nfunction getCurrentPosition(success) {\n  var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n  invariant(typeof options === 'object', 'options must be an object.');\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\nfunction _getCurrentPositionAsyncWrapper(success, error, options) {\n  var result;\n  return _regeneratorRuntime.async(function _getCurrentPositionAsyncWrapper$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          _context13.prev = 0;\n          _context13.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n        case 3:\n          _context13.next = 5;\n          return _regeneratorRuntime.awrap(getCurrentPositionAsync(options));\n        case 5:\n          result = _context13.sent;\n          success(result);\n          _context13.next = 12;\n          break;\n        case 9:\n          _context13.prev = 9;\n          _context13.t0 = _context13[\"catch\"](0);\n          error(_context13.t0);\n        case 12:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, [[0, 9]], Promise);\n}\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          _context14.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.getPermissionsAsync());\n        case 2:\n          return _context14.abrupt(\"return\", _context14.sent);\n        case 3:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          _context15.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n        case 2:\n          return _context15.abrupt(\"return\", _context15.sent);\n        case 3:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasServicesEnabledAsync() {\n  return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          _context16.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.hasServicesEnabledAsync());\n        case 2:\n          return _context16.abrupt(\"return\", _context16.sent);\n        case 3:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateTaskName(taskName) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\nexport function isBackgroundLocationAvailableAsync() {\n  var providerStatus;\n  return _regeneratorRuntime.async(function isBackgroundLocationAvailableAsync$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _context17.next = 2;\n          return _regeneratorRuntime.awrap(getProviderStatusAsync());\n        case 2:\n          providerStatus = _context17.sent;\n          return _context17.abrupt(\"return\", providerStatus.backgroundModeEnabled);\n        case 4:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function startLocationUpdatesAsync(taskName) {\n  var options,\n    _args18 = arguments;\n  return _regeneratorRuntime.async(function startLocationUpdatesAsync$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          options = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : {\n            accuracy: LocationAccuracy.Balanced\n          };\n          _validateTaskName(taskName);\n          _context18.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocation.startLocationUpdatesAsync(taskName, options));\n        case 4:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function stopLocationUpdatesAsync$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          _validateTaskName(taskName);\n          _context19.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopLocationUpdatesAsync(taskName));\n        case 3:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedLocationUpdatesAsync$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _validateTaskName(taskName);\n          return _context20.abrupt(\"return\", ExpoLocation.hasStartedLocationUpdatesAsync(taskName));\n        case 2:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var _iterator = _createForOfIteratorHelperLoose(regions), _step; !(_step = _iterator()).done;) {\n    var region = _step.value;\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\nexport function startGeofencingAsync(taskName) {\n  var regions,\n    _args21 = arguments;\n  return _regeneratorRuntime.async(function startGeofencingAsync$(_context21) {\n    while (1) {\n      switch (_context21.prev = _context21.next) {\n        case 0:\n          regions = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : [];\n          _validateTaskName(taskName);\n          _validateRegions(regions);\n          _context21.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.startGeofencingAsync(taskName, {\n            regions: regions\n          }));\n        case 5:\n        case \"end\":\n          return _context21.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function stopGeofencingAsync$(_context22) {\n    while (1) {\n      switch (_context22.prev = _context22.next) {\n        case 0:\n          _validateTaskName(taskName);\n          _context22.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopGeofencingAsync(taskName));\n        case 3:\n        case \"end\":\n          return _context22.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedGeofencingAsync$(_context23) {\n    while (1) {\n      switch (_context23.prev = _context23.next) {\n        case 0:\n          _validateTaskName(taskName);\n          return _context23.abrupt(\"return\", ExpoLocation.hasStartedGeofencingAsync(taskName));\n        case 2:\n        case \"end\":\n          return _context23.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function installWebGeolocationPolyfill() {\n  if (Platform.OS !== 'web') {\n    window.navigator.geolocation = {\n      getCurrentPosition: getCurrentPosition,\n      watchPosition: watchPosition,\n      clearWatch: clearWatch,\n      stopObserving: function stopObserving() {}\n    };\n  }\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };","map":{"version":3,"mappings":"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","names":["EventEmitter","Platform","CodedError","invariant","PermissionStatus","ExpoLocation","LocationEventEmitter","LocationAccuracy","LocationActivityType","Accuracy","ActivityType","GeofencingEventType","GeofencingRegionState","nextWatchId","headingId","_getNextWatchId","_getCurrentWatchId","watchCallbacks","deviceEventSubscription","headingEventSub","googleApiKey","googleApiUrl","getProviderStatusAsync","enableNetworkProviderAsync","OS","getCurrentPositionAsync","options","getLastKnownPositionAsync","getHeadingAsync","Promise","resolve","reject","tries","headingSub","addListener","heading","accuracy","removeSubscription","done","watchHeadingAsync","subscription","remove","callback","_removeHeadingWatcher","watchId","removeWatchAsync","watchDeviceHeading","_maybeInitializeEmitterSubscription","location","geocodeAsync","address","catch","platformUsesGoogleMaps","error","code","message","_googleGeocodeAsync","reverseGeocodeAsync","latitude","longitude","TypeError","_googleReverseGeocodeAsync","setApiKey","apiKey","fetch","encodeURI","result","json","resultObject","status","assertGeocodeResults","results","map","geometry","lat","lng","address_components","forEach","component","types","includes","city","long_name","street","region","country","postalCode","name","error_message","watchPosition","success","watchPositionImplAsync","_removeWatcher","err","watchPositionAsync","clearWatch","Object","keys","length","getCurrentPosition","_getCurrentPositionAsyncWrapper","requestPermissionsAsync","getPermissionsAsync","hasServicesEnabledAsync","_validateTaskName","taskName","isBackgroundLocationAvailableAsync","providerStatus","backgroundModeEnabled","startLocationUpdatesAsync","Balanced","stopLocationUpdatesAsync","hasStartedLocationUpdatesAsync","_validateRegions","regions","Error","radius","startGeofencingAsync","stopGeofencingAsync","hasStartedGeofencingAsync","installWebGeolocationPolyfill","window","navigator","geolocation","stopObserving"],"sourceRoot":"","sources":["../src/Location.ts"],"sourcesContent":["import { EventEmitter, Platform, CodedError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport {\n  PermissionResponse as UMPermissionResponse,\n  PermissionStatus,\n} from 'unimodules-permissions-interface';\n\nimport ExpoLocation from './ExpoLocation';\n\nconst LocationEventEmitter = new EventEmitter(ExpoLocation);\n\nexport interface ProviderStatus {\n  locationServicesEnabled: boolean;\n  backgroundModeEnabled: boolean;\n  gpsAvailable?: boolean;\n  networkAvailable?: boolean;\n  passiveAvailable?: boolean;\n}\n\nexport interface LocationOptions {\n  accuracy?: LocationAccuracy;\n  maximumAge?: number;\n  enableHighAccuracy?: boolean;\n  timeInterval?: number;\n  distanceInterval?: number;\n  timeout?: number;\n  mayShowUserSettingsDialog?: boolean;\n}\n\nexport interface LocationData {\n  coords: {\n    latitude: number;\n    longitude: number;\n    altitude: number;\n    accuracy: number;\n    heading: number;\n    speed: number;\n  };\n  timestamp: number;\n}\n\nexport interface HeadingData {\n  trueHeading: number;\n  magHeading: number;\n  accuracy: number;\n}\n\nexport interface GeocodedLocation {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n}\n\nexport interface Address {\n  city: string;\n  street: string;\n  region: string;\n  country: string;\n  postalCode: string;\n  name: string;\n}\n\nexport { PermissionStatus };\n\nexport type PermissionDetailsLocationIOS = {\n  scope: 'whenInUse' | 'always';\n};\n\nexport type PermissionDetailsLocationAndroid = {\n  scope: 'fine' | 'coarse' | 'none';\n};\n\nexport interface PermissionResponse extends UMPermissionResponse {\n  ios?: PermissionDetailsLocationIOS;\n  android?: PermissionDetailsLocationAndroid;\n}\n\nexport interface LocationTaskOptions {\n  accuracy?: LocationAccuracy;\n  timeInterval?: number; // Android only\n  distanceInterval?: number;\n  showsBackgroundLocationIndicator?: boolean; // iOS only\n  deferredUpdatesDistance?: number;\n  deferredUpdatesTimeout?: number;\n  deferredUpdatesInterval?: number;\n\n  // iOS only\n  activityType?: LocationActivityType;\n  pausesUpdatesAutomatically?: boolean;\n\n  foregroundService?: {\n    notificationTitle: string;\n    notificationBody: string;\n    notificationColor?: string;\n  };\n}\n\nexport interface LocationRegion {\n  identifier?: string;\n  latitude: number;\n  longitude: number;\n  radius: number;\n  notifyOnEnter?: boolean;\n  notifyOnExit?: boolean;\n}\n\ntype Subscription = {\n  remove: () => void;\n};\nexport type LocationCallback = (data: LocationData) => any;\nexport type LocationHeadingCallback = (data: HeadingData) => any;\n\nenum LocationAccuracy {\n  Lowest = 1,\n  Low = 2,\n  Balanced = 3,\n  High = 4,\n  Highest = 5,\n  BestForNavigation = 6,\n}\n\nenum LocationActivityType {\n  Other = 1,\n  AutomotiveNavigation = 2,\n  Fitness = 3,\n  OtherNavigation = 4,\n  Airborne = 5,\n}\n\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\n\nexport enum GeofencingEventType {\n  Enter = 1,\n  Exit = 2,\n}\n\nexport enum GeofencingRegionState {\n  Unknown = 0,\n  Inside = 1,\n  Outside = 2,\n}\n\nlet nextWatchId = 0;\nlet headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\n\nlet watchCallbacks: {\n  [watchId: number]: LocationCallback | LocationHeadingCallback;\n} = {};\n\nlet deviceEventSubscription: Subscription | null;\nlet headingEventSub: Subscription | null;\nlet googleApiKey;\nconst googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\n\nexport async function getProviderStatusAsync(): Promise<ProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationData> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\nexport async function getLastKnownPositionAsync(): Promise<LocationData> {\n  return ExpoLocation.getLastKnownPositionAsync();\n}\n\n// Start Compass Module\n\n// To simplify, we will call watchHeadingAsync and wait for one update To ensure accuracy, we wait\n// for a couple of watch updates if the data has low accuracy\nexport async function getHeadingAsync(): Promise<HeadingData> {\n  return new Promise<HeadingData>(async (resolve, reject) => {\n    try {\n      // If there is already a compass active (would be a watch)\n      if (headingEventSub) {\n        let tries = 0;\n        const headingSub = LocationEventEmitter.addListener(\n          'Expo.headingChanged',\n          ({ heading }: { heading: HeadingData }) => {\n            if (heading.accuracy > 1 || tries > 5) {\n              resolve(heading);\n              LocationEventEmitter.removeSubscription(headingSub);\n            } else {\n              tries += 1;\n            }\n          }\n        );\n      } else {\n        let done = false;\n        let subscription;\n        let tries = 0;\n        subscription = await watchHeadingAsync((heading: HeadingData) => {\n          if (!done) {\n            if (heading.accuracy > 1 || tries > 5) {\n              subscription.remove();\n              resolve(heading);\n              done = true;\n            } else {\n              tries += 1;\n            }\n          } else {\n            subscription.remove();\n          }\n        });\n\n        if (done) {\n          subscription.remove();\n        }\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<{ remove: () => void }> {\n  // Check if there is already a compass event watch.\n  if (headingEventSub) {\n    _removeHeadingWatcher(headingId);\n  }\n\n  headingEventSub = LocationEventEmitter.addListener(\n    'Expo.headingChanged',\n    ({ watchId, heading }: { watchId: string; heading: HeadingData }) => {\n      const callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(heading);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    }\n  );\n\n  headingId = _getNextWatchId();\n  watchCallbacks[headingId] = callback;\n  await ExpoLocation.watchDeviceHeading(headingId);\n  return {\n    remove() {\n      _removeHeadingWatcher(headingId);\n    },\n  };\n}\n\n// Removes the compass listener and sub from JS and Native\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\n// End Compass Module\n\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener(\n      'Expo.locationChanged',\n      ({ watchId, location }: { watchId: string; location: LocationData }) => {\n        const callback = watchCallbacks[watchId];\n        if (callback) {\n          callback(location);\n        } else {\n          ExpoLocation.removeWatchAsync(watchId);\n        }\n      }\n    );\n  }\n}\n\nexport async function geocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  return ExpoLocation.geocodeAsync(address).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new CodedError(\n          error.code,\n          `${error.message} Please set a Google API Key to use geocoding.`\n        );\n      }\n      return _googleGeocodeAsync(address);\n    }\n    throw error;\n  });\n}\n\nexport async function reverseGeocodeAsync(location: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location should be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  return ExpoLocation.reverseGeocodeAsync(location).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new CodedError(\n          error.code,\n          `${error.message} Please set a Google API Key to use geocoding.`\n        );\n      }\n      return _googleReverseGeocodeAsync(location);\n    }\n    throw error;\n  });\n}\n\nexport function setApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nasync function _googleGeocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  const result = await fetch(`${googleApiUrl}?key=${googleApiKey}&address=${encodeURI(address)}`);\n  const resultObject = await result.json();\n\n  if (resultObject.status === 'ZERO_RESULTS') {\n    return [];\n  }\n\n  assertGeocodeResults(resultObject);\n\n  return resultObject.results.map(result => {\n    let location = result.geometry.location;\n    // TODO: This is missing a lot of props\n    return {\n      latitude: location.lat,\n      longitude: location.lng,\n    };\n  });\n}\n\nasync function _googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  const result = await fetch(\n    `${googleApiUrl}?key=${googleApiKey}&latlng=${options.latitude},${options.longitude}`\n  );\n  const resultObject = await result.json();\n\n  if (resultObject.status === 'ZERO_RESULTS') {\n    return [];\n  }\n\n  assertGeocodeResults(resultObject);\n\n  return resultObject.results.map(result => {\n    const address: any = {};\n\n    result.address_components.forEach(component => {\n      if (component.types.includes('locality')) {\n        address.city = component.long_name;\n      } else if (component.types.includes('street_address')) {\n        address.street = component.long_name;\n      } else if (component.types.includes('administrative_area_level_1')) {\n        address.region = component.long_name;\n      } else if (component.types.includes('country')) {\n        address.country = component.long_name;\n      } else if (component.types.includes('postal_code')) {\n        address.postalCode = component.long_name;\n      } else if (component.types.includes('point_of_interest')) {\n        address.name = component.long_name;\n      }\n    });\n    return address as Address;\n  });\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n// Polyfill: navigator.geolocation.watchPosition\nfunction watchPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(err => {\n    _removeWatcher(watchId);\n    error({ watchId, message: err.message, code: err.code });\n  });\n\n  return watchId;\n}\n\nexport async function watchPositionAsync(options: LocationOptions, callback: LocationCallback) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = callback;\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      _removeWatcher(watchId);\n    },\n  };\n}\n\n// Polyfill: navigator.geolocation.clearWatch\nfunction clearWatch(watchId: number) {\n  _removeWatcher(watchId);\n}\n\nfunction _removeWatcher(watchId) {\n  // Do nothing if we have already removed the subscription\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\n\ntype GeoSuccessCallback = (data: LocationData) => void;\ntype GeoErrorCallback = (error: any) => void;\n\nfunction getCurrentPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback = () => {},\n  options: LocationOptions = {}\n): void {\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n\n  invariant(typeof options === 'object', 'options must be an object.');\n\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\n\n// This function exists to let us continue to return undefined from getCurrentPosition, while still\n// using async/await for the internal implementation of it\nasync function _getCurrentPositionAsyncWrapper(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n): Promise<any> {\n  try {\n    await ExpoLocation.requestPermissionsAsync();\n    const result = await getCurrentPositionAsync(options);\n    success(result);\n  } catch (e) {\n    error(e);\n  }\n}\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// --- Location service\n\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\n\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport function installWebGeolocationPolyfill(): void {\n  if (Platform.OS !== 'web') {\n    // Polyfill navigator.geolocation for interop with the core react-native and web API approach to\n    // geolocation\n    // @ts-ignore\n    window.navigator.geolocation = {\n      getCurrentPosition,\n      watchPosition,\n      clearWatch,\n\n      // We don't polyfill stopObserving, this is an internal method that probably should not even exist\n      // in react-native docs\n      stopObserving: () => {},\n    };\n  }\n}\n\nexport {\n  // For internal purposes\n  LocationEventEmitter as EventEmitter,\n  _getCurrentWatchId,\n};\n"]},"metadata":{},"sourceType":"module"}